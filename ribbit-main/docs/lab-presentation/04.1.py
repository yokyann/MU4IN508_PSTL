# fr: Après l'exécution de la commande 
# en: After the execution of the command

#   $./rsc -t py -l max tests/50-repl.scm -o ../presentation/04.1.py

# ;; fr: la string est substituée
# ;; en: this string is replaced 
#        |
#        v
input="R<fi,enifed,adbmal,,,,,,,,,,,*,,,,<,,,,,,,-,,,,,,,,;9:]:9:?Z7?YPZ?^97~Z,^YJ?VvCvR3y]?7#ZI^z]I9(i&:EiS)ai&kkz!S):kw)k]%)_*Z%aC_J^~G^{!I)^8IZ/lbC`^)`~>_J_~G_|]+9)`^YIka_CaJ`.Z+dCbAai$J`^~G_|]K#`kn8:^~i$#`kn8:^~i$#`kn8:^~i$#`kn8:^~WQ^~>w(O^~>kYF^~W^z]5#ZKa_l{])#a_k#k_k~>iS)_{!;.b.:RfCdbw(k~GCaJ`^|!O.R:h-w4k.Rf~>iS)fdAaaa^}(]&*i&^z]**Z&`^{]-*Z*b`^|!=*Z-ca_wC|!.#b`n8OfAi&AbwS\'awS\'`9+Aea_`~YN_C`.ci$.cTANdwS,ACFcwS&JFa.cACFbwS&~>JFbwS*~GCa_~>wS,^.ci$.cK^.cKZ-TANgwS+wS\'wS\'Z&Z*`wS\'wS%~GNbFa~GCa_~>wS+^.ci%.cK^.cKTi$ANdxP^~GNbFa~GCa_~>xP^8OfNdF`J_`JF`~>wS%^8;cCa_~>wS&^#Z)exN#d~YGbZ(i&:RiS)NeZ%AAfi$i$akYE_nF`~>wA^.:EgZ=ecEfYHdboFa_~>wC^.Z5dYIlbFbYHa_~K>wB_8OfAi&AbwS\'awS\'`9+Aea_`~YN_C`.ci$.cTANdwS,ACFcwS&JFa.cACFbwS&~>JFbwS*~GCa_~>wS,^.ci$.cK^.cKZ-TANgwS+wS\'wS\'Z&Z*`wS\'wS%~GNbFa~GCa_~>wS+^.ci%.cK^.cKTi$ANdxP^~GNbFa~GCa_~>xP^8OfNdF`J_`JF`~>wS%^8;cCa_~>wS&^#Z)exN#d~YGbZ(i&:RiS)NeZ%AAfi$i$akYE_nF`~>wA^.:EgZ=ecEfYHdboFa_~>wC^.Z5dYIlbFbYHa_~K^~^>wS#^#cFan~>wS.^J_~G_#bYIk``m~YN_|!?1_?H^{]71uy!9)i$89aC_?H^89aC_?H^?HvS#~K>vS#_89aC_?H^89aC_?H^?HvS#~K^~^>vE^89aC_?HvS;?HvS#~>t^89aC_?HvS9?HvS#~>v0^89aC_?HvS5?HvS#~>u^89aC_?H^~Z6`J^~G^{]3)i$)i$93C^?YPJ^~G^?HvC~G^z]\'9\'ZG^8?vS7vF~ZE^8PZJ^?HvF~ZC^89i$Z$^~Z9^9\'ZL^~YN^1vL?Z3C^?YPJ^?HvK~G^8?vLvK~YG^8?vS;vF~>i%^8?vS-vF~Z6^z!P9\'^1vE?Pi%Z$^?HvE~Z9^z];9;8L~>u^)^~Ik^Dy!L8L?D)^9;~>vR0^~I_vC)iS-~Z,^Sy!>8>A`^8>Aa^8>Aat~>vS;^8>Aav0~>vS9^8>Aau~>vS5^D~>vS#^9F_~>vE^)i&~Z,^Dz!K*YK^?D)i&~KKIvD`*YK^?D)i&~KK^~^>vL_*YK^?D)i&~K^~^>vK^Sy]8*Z8^YJ)i&?D~>vL^YLy!5)_5BBvRL_M`v3?D~i$)_5BBvRL_M`v3?D~IvS.^~I_vS\'5BBvR,_M`v3?D~i$)_5BBvRL_M`v3?D~i$)_5BBvRL_M`v3?D~IvS.^~I_vS\'5BBvR,_M`v3?D~IvR<^~I_vR55BBvR%_M`v3?D~i$)_5BBvRL_M`v3?D~i$)_5BBvRL_M`v3?D~IvS.^~I_vS\'5BBvR,_M`v3?D~i$)_5BBvRL_M`v3?D~i$)_5BBvRL_M`v3?D~IvS.^~I_vS\'5BBvR,_M`v3?D~IvR<^~I_vR55BBvR%_M`v3?D~IvR/^~I_vR$Sz!J9M`)^~^^ZB^Z#AYK^?D9#Ui&?D~>vE^*Ai&YJwS.?D~>vJ^92YJ+Lkk5k?D~>vP^S?D~K>vRM_92YJ+Lkk5k?D~>vP^S?D~K^~^>vS?^)i%?D~>vS;^)i$?D~>vS-^S?D~>vF^98?D~>vK^)^~Ik^YLy!<)^!S$^Dy]4)^!S$iS()^~>iS-^!S$^z!-94^94Z@~>iS(^)^~>iS-^iS$y!S$iS(],\'iS-^z](#l`^{]EYDl]JiF]2#oYE_^z]CYDo]$iF]##nYE_^z]9YDn]0)_)i$)i$90BBvR%`MbuC_~IvR/^~I_vR$J^~G^{]190k^)i$~YG^z]B)i$+_k~^Z1^91C^~>vPJ^)i$~YG^Z$^z].)^9._`~IakAb^Z/BMu``vR%ZDu^{]G9#Z.i&^9#AZ.i&B`kvP~Ik^z?ZHki#]OOi#]>)^]OAjO^ZA^9>Oa_)^~YM`O^YF_~G_{]M9>jO^z]Li8]A#m_i$z!NYDm]<)_9<AaJ_C^~G^{]F9<i&^z!E)k9/YEC_l~G^z!G\'i&^z]=8HO^z!H/O^z!788O^z!/8FO^z!,i8!3iF!*#k`^{!0YDk!M)i$)i$)i$)i$8MYFaYF_~YMOaO_~YMQaQ_~W`)i$~>pQ_~W_)^~^>`^{]6\'i$^z!D9N)i$\'bQ^~W^zz!S(Bmk!S-Blk!):lkl!(:lkm!4:lkn]N:lko!@:lkp!F:lkq!8:lkr!::lks]H:lku!\':lkv/!2:lkv0]/:lkv1!+:lkv2!6:lkv3]D:lkv4]@:lkv5!1:lkv6y" # RVM code that prints HELLO!

import sys

stdo=sys.stdout

putchar=lambda c:[stdo.write(chr(c)),stdo.flush(),c][2]

def getchar():
 c=sys.stdin.read(1)
 push(ord(c) if len(c) else -1)

debug = False                                                           # DEBUG
tracing = False                                                         # DEBUG
step_count = 0                                                          # DEBUG
start_tracing = 0                                                       # DEBUG
next_stamp = 0                                                          # DEBUG
                                                                        # DEBUG
def show(obj):                                                          # DEBUG
 if not is_rib(obj): return str(obj)                                    # DEBUG
 type = obj[2]                                                          # DEBUG
 if type == 4: return "#" + show(obj[0])                                # DEBUG
 result = ""                                                            # DEBUG
 if type == 0:                                                          # DEBUG
  n = 1                                                                 # DEBUG
  result += "(" + show(obj[0])                                          # DEBUG
  obj = obj[1]                                                          # DEBUG
  while is_rib(obj) and obj[2] == 0:                                    # DEBUG
   if n > 4:                                                            # DEBUG
    result += " ..."                                                    # DEBUG
    obj = NIL                                                           # DEBUG
    break                                                               # DEBUG
   result += " " + show(obj[0])                                         # DEBUG
   obj = obj[1]                                                         # DEBUG
   n += 1                                                               # DEBUG
  if obj is not NIL:                                                    # DEBUG
   result += " . " + show(obj)                                          # DEBUG
  result += ")"                                                         # DEBUG
 elif type == 1:                                                        # DEBUG
  if is_rib(obj[0]):                                                    # DEBUG
   result += "#<procedure nparams=" + str(obj[0][0]) + ">"              # DEBUG
  else:                                                                 # DEBUG
   result += "#<primitive " + str(obj[0]) + ">"                         # DEBUG
 elif type == 2:                                                        # DEBUG
  obj = obj[1]                                                          # DEBUG
  if is_rib(obj) and obj[2] == 3 and obj[1] > 0:                        # DEBUG
   obj = obj[0]                                                         # DEBUG
   while is_rib(obj) and obj[2] == 0:                                   # DEBUG
    result += chr(obj[0])                                               # DEBUG
    obj = obj[1]                                                        # DEBUG
  else:                                                                 # DEBUG
   result += "#<symbol " + show(obj) + ">"                              # DEBUG
 elif type == 3:                                                        # DEBUG
  result += "\""                                                        # DEBUG
  obj = obj[0]                                                          # DEBUG
  while is_rib(obj) and obj[2] == 0:                                    # DEBUG
   c = chr(obj[0])                                                      # DEBUG
   if c == "\n": c = "n"; result += "\\"                                # DEBUG
   elif c == "\r": c = "r"; result += "\\"                              # DEBUG
   elif c == "\t": c = "t"; result += "\\"                              # DEBUG
   elif c == "\\" or c == "\"": result += "\\"                          # DEBUG
   result += c                                                          # DEBUG
   obj = obj[1]                                                         # DEBUG
  result += "\""                                                        # DEBUG
 elif type == 5:                                                        # DEBUG
  if obj is FALSE:                                                      # DEBUG
   result += "#f"                                                       # DEBUG
  elif obj is TRUE:                                                     # DEBUG
   result += "#t"                                                       # DEBUG
  elif obj is NIL:                                                      # DEBUG
   result += "()"                                                       # DEBUG
  else:                                                                 # DEBUG
   result += "["+show(obj[0])+","+show(obj[1])+","+show(obj[2])+"]"     # DEBUG
 else:                                                                  # DEBUG
  result += "["+show(obj[0])+","+show(obj[1])+","+show(obj[2])+"]"      # DEBUG
 return result                                                          # DEBUG
                                                                        # DEBUG
def start_step():                                                       # DEBUG
 global step_count, tracing, next_stamp                                 # DEBUG
 step_count += 1                                                        # DEBUG
 if step_count >= start_tracing: tracing = True                         # DEBUG
 if not tracing:                                                        # DEBUG
  if step_count >= next_stamp:                                          # DEBUG
   next_stamp = int(next_stamp * 1.01 + 1)                              # DEBUG
   print("@" + str(step_count))                                         # DEBUG
  return                                                                # DEBUG
 s = stack                                                              # DEBUG
 result = "@" + str(step_count) + " STACK = ("                          # DEBUG
 sep = ""                                                               # DEBUG
 while s[2]==0: result += sep + show(s[0]); sep = " "; s=s[1]           # DEBUG
 result += ")"                                                          # DEBUG
 print(result)                                                          # DEBUG

pos=-1
def get_byte():
 global pos
 pos+=1
 return ord(input[pos])

# VM

FALSE=[0,0,5]
TRUE=[0,0,5]
NIL=[0,0,5]

to_bool=lambda x:TRUE if x else FALSE
is_rib=lambda x:type(x) is list

stack=0

def push(x):
 global stack
 stack=[x,stack,0]

def pop():
 global stack
 x=stack[0]
 stack=stack[1]
 return x

prim1=lambda f:lambda:push(f(pop()))
prim2=lambda f:lambda:push(f(pop(),pop()))
prim3=lambda f:lambda:push(f(pop(),pop(),pop()))

def arg2():x = pop();pop();push(x)
def close():push([pop()[0],stack,1])
def f0s(y,x):x[0]=y;return y
def f1s(y,x):x[1]=y;return y
def f2s(y,x):x[2]=y;return y

# Section des primitives
#    |
#    |
#    v
primitives = [
 prim3(lambda z,y,x:[x,y,z]),
 prim1(lambda x:x),
 pop,
 arg2,
 close,
 prim1(lambda x:to_bool(is_rib(x))),
 prim1(lambda x:x[0]),
 prim1(lambda x:x[1]),
 prim1(lambda x:x[2]),
 prim2(f0s),
 prim2(f1s),
 prim2(f2s),
 prim2(lambda y,x:to_bool(x is y if is_rib(x) or is_rib(y) else x==y)),
 prim2(lambda y,x:to_bool(x<y)),
 prim2(lambda y,x:x+y),
 prim2(lambda y,x:x-y),
 prim2(lambda y,x:x*y),
 prim2(lambda y,x:int(x/y)),
 getchar,
 prim1(putchar),
 prim1(exit)
]

def get_code():
 x=get_byte()-35
 return 57 if x<0 else x

def get_int(n):
 x=get_code()
 n*=46
 return n+x if x<46 else get_int(n+x-46)

list_tail=lambda lst,i:lst if i==0 else list_tail(lst[1],i-1)

# build the initial symbol table

symtbl=NIL
n=get_int(0)
while n>0:
 n-=1
 symtbl=[[FALSE,[NIL,0,3],2],symtbl,0]

accum=NIL
n=0
while 1:
 c=get_byte()
 if c==44:
  symtbl=[[FALSE,[accum,n,3],2],symtbl,0]; accum=NIL; n=0
 else:
  if c==59: break
  accum=[c,accum,0]
  n+=1

symtbl=[[FALSE,[accum,n,3],2],symtbl,0]
symbol_ref=lambda n: list_tail(symtbl,n)[0]

# decode the RVM instructions

while 1:
 x=get_code()
 n=x
 d=0
 op=0
 while 1:
  d=[20,30,0,10,11,4][op]
  if n<=2+d:break
  n-=d+3;op+=1
 if x>90:
  n=pop()
 else:
  if op==0:stack=[0,stack,0];op+=1
  n = get_int(0)if n==d else symbol_ref(get_int(n-d-1))if n>=d else symbol_ref(n)if op<3 else n
  if 4<op:
   n=[[n,0,pop()],NIL,1]
   if not stack:break
   op=4
 stack[0]=[op-1,n,stack[0]]

pc = n[0][2]

get_opnd=lambda o:(o if is_rib(o) else list_tail(stack,o))

def get_cont():
 s=stack
 while not s[2]:s=s[1]
 return s

def set_global(val):
 global symtbl
 symtbl[0][0]=val
 symtbl=symtbl[1]

set_global([0,symtbl,1]) # primitive 0
set_global(FALSE)
set_global(TRUE)
set_global(NIL)

stack=[0,0,[5,0,0]] # primordial continuation (executes halt instr.)

while 1:
 if debug: start_step() # DEBUG
 o=pc[1]
 i=pc[0]
 if i<1: # jump/call
  if tracing: print(("call " if is_rib(pc[2]) else "jump ") + show(o)) # DEBUG
  o=get_opnd(o)[0]
  c=o[0]
  if is_rib(c):
   c2=[0,o,0]
   s2=c2
   nargs=c[0]
   while nargs:s2=[pop(),s2,0];nargs-=1
   if is_rib(pc[2]): # call
    c2[0]=stack
    c2[2]=pc[2]
   else: # jump
    k=get_cont()
    c2[0]=k[0]
    c2[2]=k[2]
   stack=s2
  else:
   primitives[c]()
   if is_rib(pc[2]): # call
    c=pc
   else: # jump
    c=get_cont()
    stack[1]=c[0]
  pc=c[2]
 elif i<2: # set
  if tracing: print("set " + show(o)) # DEBUG
  get_opnd(o)[0]=stack[0]; stack = stack[1]
  pc=pc[2]
 elif i<3: # get
  if tracing: print("get " + show(o)) # DEBUG
  push(get_opnd(o)[0])
  pc=pc[2]
 elif i<4: # const
  if tracing: print("const " + show(o)) # DEBUG
  push(o)
  pc=pc[2]
 elif i<5: # if
  if tracing: print("if") # DEBUG
  pc=pc[2 if pop()is FALSE else 1]
 else: # halt
  if tracing: print("halt") # DEBUG
  break

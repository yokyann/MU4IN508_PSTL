(* RVM code that prints HELLO! *)
let input = "R\'rdadac,>,=>,qssa,oludom,htgnel-rotcev,?=<rahc,?qe,rahc-etirw,?regetni,?orez,etacnurt,xam,?=gnirts,!llif-rotcev,!tes-gnirts,gnirtsbus,regetni>-rahc,htgnel-gnirts,gniliec,tel,fer-rotcev,?=>gnirts,raaaac,?=>rahc,rddaac,dna,?=rahc,!tes,=,raddac,?<rahc,rotaremun,mcl,rotcev-ekam,enifed,!llif-gnirts,rahc>-regetni,?>rahc,qmem,rdaaac,adbmal,?naeloob,raaddc,?=<gnirts,?evitisop,gnirts-ekam,radaac,rotanimoned,!rdc-tes,raaadc,raadac,rddadc,ro,rorre,fi,nim,roolf,?evitagen,etouq,!tes-rotcev,cc/llac,ypoc-gnirts,dnuor,radddc,nigeb,radadc,=<,dnoc,rdaddc,rdaadc,rddddc,dneppa-gnirts,?ddo,tixe,?<gnirts,pam,vmem,?>gnirts,?erudecorp,tsil>-rotcev,tpxe,gnirts>-rebmun,esrever,?rotcev,!rac-tes,fer-gnirts,redniamer,cossa,rebmun>-gnirts,lave,rebmem,vssa,?neve,hcae-rof,dcg,lobmys>-gnirts,gnirts>-lobmys,raac,radc,raadc,raaac,rdddac,lper,?gnirts,rdadc,rdaac,fer-tsil,radac,raddc,rdddc,?tcejbo-foe,enilwen,rotcev>-tsil,dneppa,+,sba,?lobmys,?llun,yalpsid,etirw,htgnel,daer,rahc-keep,?lauqe,rddac,tneitouq,,gnirts>-tsil,tsil>-gnirts,ton,,,rddc,,,*,,rdac,,,,rac,?riap,rahc-daer,<,-,rdc,snoc,,?vqe,,,,,;9)!S,9Fl@YN@YF_@YGiU7@YG^{])9)@YN@YFZ6^8N~YO^YD@YT8vCvR3y]67#YU.^z!U.8THi&:HiU6ai&kkz!U6:kw\'k!TJ\'_*YTJaB_G^~F^{!T9\'^8T9YKlbB`^\'`~?_G_~F_|!TA8TG`^YT9ka_BaG`1YTAdBbAai$G`^~F_|!U/#`kn8:^~i$#`kn8:^~i$#`kn8:^~i$#`kn8:^~YT5Q^~?w)I^~?kJ^~YT5^z!U\'#YU/a_l{!TG#a_k#k_k~?iU6_{!?1b1:VfBdbw)k~FBaG`^|!T<1V:h-w7k1Vf~?iU6fdAaaa^}(!TF*i&^z!TI*YTF`^{!TB*YTIb`^|!T7*YTBca_wS+|!1#b`n8T<fAi&AbwU4awU4`8TAAea_`~YI_B`1ci$1cYT7APdxLABKcxOGKa1cABKbxO~?GKbwU5~FBa_~?xL^1ci$1cN^1cNYTBYT7APgwS-wU4wU4YTFYTI`wU4wSN~FPbKa~FBa_~?wS-^1ci%1cN^1cNYT7i$APdwSH^~FPbKa~FBa_~?wSH^8T<fPdK`G_`GK`~?wSN^8?cBa_~?xO^#YTGewT?#d~YHbYTHi&:ViU6PeYTJAAfi$i$akYE_nK`~?wS9^1:HgZ*ecHfYAdboKa_~?wS+^1YU\'dYT9lbKbYAa_~N?wS?_8T<fAi&AbwU4awU4`8TAAea_`~YI_B`1ci$1cYT7APdxLABKcxOGKa1cABKbxO~?GKbwU5~FBa_~?xL^1ci$1cN^1cNYTBYT7APgwS-wU4wU4YTFYTI`wU4wSN~FPbKa~FBa_~?wS-^1ci%1cN^1cNYT7i$APdwSH^~FPbKa~FBa_~?wSH^8T<fPdK`G_`GK`~?wSN^8?cBa_~?xO^#YTGewT?#d~YHbYTHi&:ViU6PeYTJAAfi$i$akYE_nK`~?wS9^1:HgZ*ecHfYAdboKa_~?wS+^1YU\'dYT9lbKbYAa_~N^~^?wSF^#cKan~?wS\'^G_~F_#bYT9k``m~YI_|!T85_@L^{!N5uy!T,i5!;\'i$8;aB_@L^8;aB_@L^@LvS#~N?vS#_8;aB_@L^8;aB_@L^@LvS#~N^~^?vE^8;aB_@LvS;@LvS#~?t^8;aB_@LvS9@LvS#~?v0^8;aB_@LvS5@LvS#~?u^8;aB_@L^~S`G^~F^{!TL\'i$\'i$8TLB^@YFG^~F^@LvC~F^z!G8GZ>^8T8vS7vF~ZA^8FZ@^@LvF~Z<^8;i$T^~Z(^8GZ/^~YI^5vL@YTLB^@YFG^@LvK~F^8T8vLvK~YH^8T8vS;vF~?i%^8T8vS-vF~S^z!F8G^5vE@Ri%T^@LvE~Z(^z!TN8TN8T>~?u^\'^~Dk^Ey!T>8T>@E\'^8TN~?vR0^~D_vC\'iU8~YO^YCy!T68T6A`^8T6Aa^8T6Aat~?vS;^8T6Aav0~?vS9^8T6Aau~?vS5^E~?vS#^9=_~?vE^\'i&~YO^Ez!T=*YT=^@E\'i&~NNDvD`*YT=^@E\'i&~NN^~^?vL_*YT=^@E\'i&~N^~^?vK^YCy!TM*YTM^YD\'i&@E~?vL^YT>y!8\'_88CCvRL_M`v3@E~i$\'_88CCvRL_M`v3@E~DvS.^~D_vS\'88CCvR,_M`v3@E~i$\'_88CCvRL_M`v3@E~i$\'_88CCvRL_M`v3@E~DvS.^~D_vS\'88CCvR,_M`v3@E~DvR<^~D_vR588CCvR%_M`v3@E~i$\'_88CCvRL_M`v3@E~i$\'_88CCvRL_M`v3@E~DvS.^~D_vS\'88CCvR,_M`v3@E~i$\'_88CCvRL_M`v3@E~i$\'_88CCvRL_M`v3@E~DvS.^~D_vS\'88CCvR,_M`v3@E~DvR<^~D_vR588CCvR%_M`v3@E~DvR/^~D_vR$YCz!D90`\'^~^^Z7^UAYT=^@E8>YT6i&@E~?vE^*Ai&YDwS\'@E~?vJ^8MYD,Okk88k@E~?vP^YC@E~N?vRM_8MYD,Okk88k@E~?vP^YC@E~N^~^?vS?^\'i%@E~?vS;^\'i$@E~?vS-^YC@E~?vF^8TM@E~?vK^\'^~Dk^YT>y!C\'^!U1^Ey!U&\'^!U1iU3\'^~?iU8^!U1^z!.8U&^8U&YU+~?iU3^\'^~?iU8^iU1y!U1iU3!O(iU8^z!S%7%YT?\'_@YU0Qc^@YTDJc^IIYT?i$zIIYT?i$z]2\'i$92B`^@X$G_~F_{]D\'i&*ZDBa_X$G_~F_{!TH#l`^{]AYT:l!T&8TDYT;aI_^{!S@8MYT;k^z!S&8TOb`J^|!SM9%`J^{!T/i2]@i3!M#oYE_^z]<YT:o!S>8TDYT;aI_^{!S$8>YLi&T^z]H8>YLT`T^{!TP8>a8TPAfZ:bb`a_Cl`~Da_}\'!T$8TPi&b`^|!U*\'k\'iU8~F_\'l8U*BbB`\'l~D`^\'iU8~D__G`G^~F_~F^{!TK8U*T`T^{!SL8<ZE`^{!S68<ZB`^{]B-YTKa_k{]E-kYTK`^{!T\'(kYTK`^{!S48>YT;vC^z!T%8TOb`J^|]:9%`J^{!SPi2!=i3!>#nYE_^z](YT:n!S=i\'!T#i\'!SJiT2!T.jM!S<iT3!SCi-!SGi(!U#\'_\'i$\'i$8U#CCvR%`MbuB_~DvR/^~D_vR$G^~F^{!U)8U#k^\'i$~YH^z]7\'i$,_k~^YU)^8U)B^~?vPG^\'i$~YH^T^z!TC\'^8TC_`~DakAb^YKCMu``vR%Wu^{]>8>YTCi&^8>AYTCi&C`kvP~Dk^z]?\'^6__~ZG`Z?Wm`M_^\'l~?k_{!S#i\'!T)i\'!SOi\'!S)i\'!S2\'lz!SBi\'!SA6_WZ1``_YJ`YJ^\'k~?k_{!T@8T@_Z9__\'_~?k^{]18T@`^8T@__~D__YJ`YJ^{!T08Kb^\'^~?DkbDk`\'k~?k^CM`a_W`^{]9,MWb``^{!J\'^,_k~Dk^z!S*\'_\'^~D`^{!T(\'^\'_~D`^{]G8<Z3^z]3(MWm`m^z!S(-k^z!S5-_kz!T*(k^z!T28<D`^{]M8<D__{!T3-__{!SEi(!T+8<YT5^z@YU,ki#!U2Ii#!U$\'^!U2AiU2^YU-^8U$Ia_\'^~YB`I^J_~F_{]08U$iU2^z]/i2!U-#m_i$z!IYT:m!U(\'`8U(Aca`Cl^~D_k|!T;8U(i&`^{]8\'i$98Ba_\'^~YBG__G_~F_{!T1j4]4\'i$94Ba_\'^~?G__G_~F_{]5\'i$95B`^\'_~YBG`^~F_{!S;jC]C\'i$9CB`^\'_~?G`^~F_{!TE\'^8TECl`B^~D`k{!TO9;aYTE`^|]%0YTE`^{!U%\'_8U%AaG_B^~F^{]=8U%i&^z!L\'_*YLaB_G^~F^{!E\'k8KYEB_l~F^z!H(i&^z]I8PI^z]P8PJ^z]K9#I^z!S79#J^z!S.9\'I^z]N9\'J^z]J9,I^z!S09,J^z!SD8AJ^z!T49$I^z!S/9$J^z!SI9&I^z!S39&J^z!S:9+I^z!SK9+J^z!P89I^z]#89J^z]\'9-I^z],9-J^z]$4J^z]&9.I^z]+9.J^z]-2J^z].3J^z]*8AI^z!A4I^z!92I^z!43I^z!S1iU,];iTD!+i2!0i3!*#k`^{!/YT:k!B\'i$\'i$\'i$\'i$8BJaJ_~YBIaI_~YBQaQ_~YT5`\'i$~?pQ_~YT5_\'^~^?`^{!T-i(!S88<_\'^~^?i%^z!<(i$^z!T:8T?\'i$(bQ^~YT5^zz!U7:nl:ki&vC!U3Cmk!U8Clk!\':lkl!):lkm!7:lkn!T?:lko!T5:lkp!3:lkq!2:lkr!::lks!TD:lkt!U,:lku!U0:lkv.!(:lkv/!-:lkv0!K:lkv1!,:lkv2!6:lkv3!@:lkv4!U+:lkv5!5:lkv6]F:lkv7y"

let debug = Sys.getenv_opt "RIBBIT_DEBUG" |> Option.is_some
let tracing = ref false
let step_count = ref 0
let start_tracing = ref 0
let next_stamp = ref 0

let _ = if debug then Printexc.record_backtrace true

module Rib = struct
  (* Rib (car, cdr, tag) *)
  type t = Rib of t ref * t ref * t ref | Integer of int

  let make_rib_of_ints a b c =
    Rib (ref (Integer a), ref (Integer b), ref (Integer c))
  let make_rib a b c = Rib (ref a, ref b, ref c)

  let is_rib = function Rib _ -> true | _ -> false
  let is_int = function Integer _ -> true | _ -> false

  let int_val = function Integer i -> i
                     | _ -> invalid_arg "int_val expects an Integer"
  let int_val_orelse i def =
    match i with
    |  Integer i -> i
    | _ -> def

  let rib_eq a b =
    match a, b with
    | Integer x, Integer y -> x = y
    | Rib _, Rib _ -> a == b
    | _ -> false

  let get_car = function Rib (car,_,_) -> !car
                       | _ -> invalid_arg "get_car expects a rib"
  let set_car rib newval =
    match rib with
    | Rib (car,_,_) -> car := newval
    | _ -> invalid_arg "set_car expects a rib"
  let get_cdr = function Rib (_,cdr,_) -> !cdr
                       | _ -> invalid_arg "get_cdr expects a rib"
  let set_cdr rib newval =
    match rib with
    | Rib (_,cdr,_) -> cdr := newval
    | _ -> invalid_arg "set_cdr expects a rib"
  let get_tag = function Rib (_,_,tag) -> !tag
                       | _ -> invalid_arg "get_tag expects a rib"
  let set_tag rib newval =
    match rib with
    | Rib (_,_,tag) -> tag := newval
    | _ -> invalid_arg "set_tag expects a rib"

  let false_rib = make_rib_of_ints 0 0 5
  let true_rib = make_rib_of_ints 0 0 5
  let nil_rib = make_rib_of_ints 0 0 5

  let to_bool = function true -> true_rib | false -> false_rib

  let write_to_buffer rib buf =
    let rec helper r =
      match r with
      | Integer i -> Printf.bprintf buf "%d" i
      | Rib _ when r == true_rib -> Buffer.add_string buf "#t"
      | Rib _ when r == false_rib -> Buffer.add_string buf "#f"
      | Rib _ when r == nil_rib -> Buffer.add_string buf "()"
      | Rib (car, cdr, tag) ->
         let obj = ref r in
         let typ = int_val_orelse !tag (-1) in
         if typ = 4 then begin
             Buffer.add_char buf '#';
             helper !car
           end else if typ = 0 then begin
             let n = ref 0 in
             Buffer.add_char buf '(';
             helper !car;
             let obj = ref !cdr in
             while is_rib !obj && int_val_orelse (get_tag !obj) (-1) = 0 do
               if !n > 4 then begin
                   Buffer.add_string buf " ...";
                   obj := nil_rib
                 end else begin
                   Buffer.add_char buf ' ';
                   helper (get_car !obj);
                   obj := get_cdr !obj;
                   incr n
                 end
             done;
             if not (!obj == nil_rib) then begin
                 Buffer.add_string buf " . ";
                 helper !obj
               end;
             Buffer.add_char buf ')'
           end else if typ = 1 then begin
             if is_rib !car then
               Printf.bprintf buf "#<procedure params=%d>" (int_val (get_car !car))
             else
               Printf.bprintf buf "#<primitive %d>" (int_val !car)
           end else if typ = 2 then begin
             obj := get_cdr !obj;
             if is_rib !obj && int_val (get_tag !obj) = 3 &&
                  int_val (get_cdr !obj) > 0 then begin
                 obj := get_car !obj;
                 while is_rib !obj && int_val (get_tag !obj) = 0 do
                   Buffer.add_char buf (get_car !obj |> int_val |> char_of_int);
                   obj := get_cdr !obj
                 done;
               end else begin
                 Buffer.add_string buf "#<symbol ";
                 helper !obj;
                 Buffer.add_char buf '>'
               end
           end else if typ = 3 then begin
             Buffer.add_char buf '"';
             obj := !car;
             while is_rib !obj && int_val (get_tag !obj) = 0 do
               begin
                 match (get_car !obj |> int_val |> char_of_int) with
                 | '\n' -> Buffer.add_string buf "\\n"
                 | '\r' -> Buffer.add_string buf "\\r"
                 | '\t' -> Buffer.add_string buf "\\t"
                 | '\\' -> Buffer.add_string buf "\\\\"
                 | '"' -> Buffer.add_string buf "\\\""
                 | c -> Buffer.add_char buf c
               end;
               obj := get_cdr !obj
             done;
             Buffer.add_char buf '"'
           end else begin
             Buffer.add_char buf '[';
             helper !car;
             Buffer.add_char buf ',';
             helper !cdr;
             Buffer.add_char  buf ',';
             helper !tag;
             Buffer.add_char buf ']'
           end in
    helper rib;
    buf

  let print_rib ?(out=stdout) rib =
    Buffer.create 16 |> write_to_buffer rib |> Buffer.output_buffer out
end

open Rib

let stack = ref (Integer 0)

let start_step () =
  incr step_count;
  if !step_count >= !start_tracing then tracing := true;
  if not !tracing then begin
      if !step_count >= !next_stamp then begin
          next_stamp := (float_of_int !next_stamp) *. 1.01 +. 1.0 |>  int_of_float;
          Printf.printf "@%d\n" !step_count;
        end
    end else begin
      let s = ref !stack in
      let buf = Buffer.create 80 in
      let sep = ref "" in
      Printf.bprintf buf "@%d STACK = (" !step_count;
      while is_rib !s && int_val_orelse (get_tag !s) (-1) = 0 do
        Buffer.add_string buf !sep;
        write_to_buffer (get_car !s) buf |> ignore;
        sep := " ";
        s := get_cdr !s
      done;
      Buffer.add_char buf ')';
      Buffer.output_buffer stdout buf;
      print_newline ();
      flush stdout
    end

let push x = stack := make_rib x !stack (Integer 0)
let pop () =
  match !stack with
  | Rib (car,cdr,_) ->
     stack := !cdr;
     !car
  | _ -> invalid_arg "Top of stack is not a rib"

module type PRIMITIVES = sig
  val primitives: (unit -> unit) array
end

module Primitives : PRIMITIVES = struct
  let prim0 f = function () -> f () |> push
  let prim1 f = function () -> pop () |> f |> push
  let prim2 f = function () ->
                  let x = pop () in
                  let y = pop () in
                  f x y |> push
  let prim3 f = function () ->
                  let x = pop () in
                  let y = pop () in
                  let z = pop () in
                  f x y z |> push

  let getchar () =
    try
      input_char stdin |> int_of_char
    with End_of_file -> -1

  let putchar c =
    char_of_int c |> print_char;
    flush stdout;
    c

  let primitives = [|
      prim3 (fun z y x -> make_rib x y z);
      prim1 (function x -> x);
      (function () -> pop () |> ignore);
      prim2 (fun y x -> y);
      prim1 (function x -> make_rib (get_car x) !stack (Integer 1));
      prim1 (function Rib _ -> true_rib | _ -> false_rib);
      prim1 get_car;
      prim1 get_cdr;
      prim1 get_tag;
      prim2 (fun y x -> set_car x y; y);
      prim2 (fun y x -> set_cdr x y; y);
      prim2 (fun y x -> set_tag x y; y);
      prim2 (fun y x -> to_bool (rib_eq x y));
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> to_bool (a < b)
                        | _ -> invalid_arg "< arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a + b)
                        | _ -> invalid_arg "+ arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a - b)
                        | _ -> invalid_arg "- arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a * b)
                        | _ -> invalid_arg "* arguments must be Integers");
      prim2 (fun y x -> match x, y with
                        | Integer a, Integer b -> Integer (a / b)
                        | _ -> invalid_arg "quotient arguments must be Integers");
      prim0 (function () -> Integer (getchar ()));
      prim1 (function Integer ch -> Integer (putchar ch) | _ -> invalid_arg "putchar argument must be Integer");
      prim1 (function Integer status -> exit status | _ -> invalid_arg "exit argument must be Integer")
    |]
end

let get_byte =
  let input_stream = Stream.of_string input in
  function () -> (Stream.next input_stream |> int_of_char)

let get_code () =
  let x = (get_byte ()) - 35 in if x < 0 then 57 else x

let rec get_int n =
  let x = get_code () in
  let n = n * 46 in
  if x < 46 then n + x else get_int (n + x - 46)

let rec list_tail lst i =
  if i = 0 then lst else list_tail (get_cdr lst) (i - 1)

(* Build the initial symbol table *)
let symtbl = ref nil_rib
let _ =
  for n = get_int 0 downto 1 do
    symtbl := make_rib (make_rib false_rib
                          (make_rib nil_rib (Integer 0) (Integer 3))
                          (Integer 2))
                !symtbl (Integer 0)
  done;
  let accum = ref nil_rib
  and n = ref 0
  and in_loop = ref true in
  while !in_loop do
    let c = get_byte () in
    if c = 44 then begin
        let r1 = make_rib !accum (Integer !n) (Integer 3) in
        let r2 = make_rib false_rib r1 (Integer 2) in
        symtbl := make_rib r2 !symtbl (Integer 0);
        accum := nil_rib;
        n := 0
      end
    else if c = 59 then
      in_loop := false
    else begin
        accum := make_rib (Integer c) !accum (Integer 0);
        incr n
      end
  done;
  symtbl := make_rib (make_rib false_rib
                        (make_rib !accum (Integer !n) (Integer 3))
                        (Integer 2))
              !symtbl (Integer 0)

let symbol_ref n = list_tail !symtbl n |> get_car

let pc = ref nil_rib

(* Decode the RVM instructions *)
let _ =
  let codes = [| 20; 30; 0; 10; 11; 4 |]
  and in_loop = ref true
  and n = ref nil_rib in
  while !in_loop do
    let x = get_code ()
    and d = ref 0
    and op = ref 0
    and in_loop2 = ref true in
    n := Integer x;
    while !in_loop2 do
      d := codes.(!op);
      if int_val !n <= 2 + !d then
        in_loop2 := false
      else begin
          n := Integer ((int_val !n) - (!d + 3));
          incr op
        end
    done;
    if x > 90 then
      n := pop ()
    else begin
        if !op = 0 then begin
            stack := make_rib (Integer 0) !stack (Integer 0);
            incr op
          end;
        n := if int_val !n = !d then
               Integer (get_int 0)
             else if int_val !n >= !d then
               get_int ((int_val !n) - !d - 1) |> symbol_ref
             else if !op < 3 then
               int_val !n |> symbol_ref
             else
               !n;
        if 4 < !op then begin
            n := make_rib (make_rib !n (Integer 0) (pop ())) nil_rib (Integer 1);
            if not (is_rib !stack) then
              in_loop := false
            else
              op := 4
          end;
      end;
    if !in_loop then
      set_car !stack (make_rib (Integer (!op - 1)) !n (get_car !stack))
  done;
  pc := get_car !n |> get_tag

let get_opnd o =
  match o with
  | Rib _ -> o
  | Integer i -> list_tail !stack i

let get_cont () =
  let s = ref !stack in
  while not (is_rib (get_tag !s)) do
    s := get_cdr !s
  done;
  !s

let set_global v =
  set_car (get_car !symtbl) v;
  symtbl := (get_cdr !symtbl)

(* Execute the program *)
let _ =
  set_global (make_rib (Integer 0) !symtbl (Integer 1));
  set_global false_rib;
  set_global true_rib;
  set_global nil_rib;
  stack := make_rib (Integer 0) (Integer 0) (make_rib_of_ints 5 0 0);
  while true do
    if debug then start_step ();
    let o = ref (get_cdr !pc)
    and i = int_val (get_car !pc) in
    if i < 1 then begin (* jump/call *)
        if !tracing then begin
            (if is_rib (get_tag !pc) then "call " else "jump ") |> prerr_string;
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        o := get_opnd !o |> get_car;
        let c = ref (get_car !o) in
        if is_rib !c then begin
            let c2 = ref (make_rib (Integer 0) !o (Integer 0)) in
            let s2 = ref !c2
            and nargs = int_val (get_car !c) in
            for narg = nargs downto 1 do
              s2 := make_rib (pop ()) !s2 (Integer 0)
            done;
            if is_rib (get_tag !pc) then begin (* call *)
                set_car !c2 !stack;
                set_tag !c2 (get_tag !pc)
              end else begin (* jump *)
                let k = get_cont () in
                set_car !c2 (get_car k);
                set_tag !c2 (get_tag k)
              end;
            stack := !s2
          end else begin
            Primitives.primitives.(int_val !c) ();
            if is_rib (get_tag !pc) then (* call *)
              c := !pc
            else begin (* jump *)
                c := get_cont ();
                set_cdr !stack (get_car !c)
              end
          end;
        pc := get_tag !c
      end else if i < 2 then begin (* set *)
        if !tracing then begin
            prerr_string "set ";
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        let opnd = get_opnd !o in
        set_car opnd (get_car !stack);
        stack := get_cdr !stack;
        pc := get_tag !pc
      end else if i < 3 then begin (* get *)
        if !tracing then begin
            prerr_string "get ";
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        let opnd = get_opnd !o in
        push (get_car opnd);
        pc := get_tag !pc
      end else if i < 4 then begin (* const *)
        if !tracing then begin
            prerr_string "const ";
            print_rib ~out:stderr !o;
            prerr_newline ()
          end;
        push !o;
        pc := get_tag !pc
      end else if i < 5 then begin (* if *)
        if !tracing then prerr_endline "if";
        pc := if pop () == false_rib then get_tag !pc else get_cdr !pc
      end else begin (* halt *)
        if !tracing then prerr_endline "halt";
        exit 0
      end
  done
